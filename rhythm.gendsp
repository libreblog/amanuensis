{
	"patcher" : 	{
		"fileversion" : 1,
		"appversion" : 		{
			"major" : 8,
			"minor" : 0,
			"revision" : 3,
			"architecture" : "x64",
			"modernui" : 1
		}
,
		"classnamespace" : "dsp.gen",
		"rect" : [ 42.0, 113.0, 826.0, 577.0 ],
		"bglocked" : 0,
		"openinpresentation" : 0,
		"default_fontsize" : 10.0,
		"default_fontface" : 0,
		"default_fontname" : "Arial",
		"gridonopen" : 2,
		"gridsize" : [ 10.0, 10.0 ],
		"gridsnaponopen" : 2,
		"objectsnaponopen" : 1,
		"statusbarvisible" : 2,
		"toolbarvisible" : 1,
		"lefttoolbarpinned" : 0,
		"toptoolbarpinned" : 0,
		"righttoolbarpinned" : 0,
		"bottomtoolbarpinned" : 0,
		"toolbars_unpinned_last_save" : 0,
		"tallnewobj" : 0,
		"boxanimatetime" : 200,
		"enablehscroll" : 1,
		"enablevscroll" : 1,
		"devicewidth" : 0.0,
		"description" : "",
		"digest" : "",
		"tags" : "",
		"style" : "",
		"subpatcher_template" : "To the Sun",
		"boxes" : [ 			{
				"box" : 				{
					"id" : "obj-12",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 651.0, 540.0, 31.0, 20.0 ],
					"text" : "out 7"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-11",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 551.0, 540.0, 31.0, 20.0 ],
					"text" : "out 6"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-10",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 520.79998779296875, 540.0, 31.0, 20.0 ],
					"text" : "out 5"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-9",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 390.600006103515625, 540.0, 31.0, 20.0 ],
					"text" : "out 4"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-8",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 260.399993896484375, 540.0, 31.0, 20.0 ],
					"text" : "out 3"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-7",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 130.199996948242188, 540.0, 31.0, 20.0 ],
					"text" : "out 2"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-6",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 651.0, 0.0, 25.0, 20.0 ],
					"text" : "in 4"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-5",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 434.0, 0.0, 25.0, 20.0 ],
					"text" : "in 3"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-1",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 0.0, 0.0, 25.0, 20.0 ],
					"text" : "in 1"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-2",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 217.0, 0.0, 25.0, 20.0 ],
					"text" : "in 2"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-4",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 0.0, 540.0, 31.0, 20.0 ],
					"text" : "out 1"
				}

			}
, 			{
				"box" : 				{
					"code" : "Buffer intervals(\"intervals\");\r\nBuffer beats(\"beats\");\r\nBuffer recitation_intervals(\"recitation_intervals\");\r\nBuffer prior_timestamps(\"prior_timestamps\");\r\nBuffer lattice(\"lattice\");\r\nBuffer tempo(\"tempo\");\r\nBuffer salient(\"salient\");\r\nBuffer stats(\"stats\");\r\nBuffer recording(\"recording\");\r\nBuffer mode(\"mode\");\r\nBuffer stable(\"stable\");\r\nBuffer unstable(\"unstable\");\r\nBuffer steady(\"steady\");\r\nBuffer play_head(\"play_head\");\r\nBuffer starting_frame(\"starting_frame\");\r\nBuffer playing(\"playing\");\r\nBuffer song(\"song\");\r\nBuffer song_beats(\"song_beats\");\r\nBuffer past_song(\"past_song\");\r\nHistory timestamps(0);\r\nParam tolerance(9);\r\nParam wake(8000);\r\nParam backing(0);\r\natom = tolerance * 2;\r\nrange = 0;\r\ntimestamp = in1;\r\npitch = in2;\r\nvelocity = in3;\r\nchannel = in4;\r\nif(channel < 0) {\t\t\t\t\t\t//recitation takes slots 17-32\r\n\tchannel = abs(channel) + 16;\r\n}\r\nout1 = -1;\r\nout2 = -1;\r\nout3 = -1;\r\nout4 = -1;\r\nout5 = -1;\r\nout7 = -1;\r\nnow = stats.peek(0);\r\nlock = stats.peek(10);\t//.peek() alone in if() fails to compile. Must resolve to expression\r\naggregate = 0;\r\nif(pitch < 0) {\t//negative pitch signals a forced miss\r\n\trecording.poke(0, channel);\r\n\tout2 = 0;\r\n\tprior_beat = beats.peek(channel, 0);\r\n\tbeats.poke(prior_beat, channel, 1);\r\n\tbeats.poke(stats.peek(5), channel, 0);\t//document beat (from ramp)\r\n\tfor(i = 0; i < dim(recording); i += 1) {\r\n\t\tchannel_recording = recording.peek(i);\r\n\t\tstats.poke(channel_recording, 9);\t//recording\r\n\t\tout1 = channel_recording;\r\n\t\tif(channel_recording) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tout3 = lock;\r\n}\r\nelse {\r\n    interval = now - prior_timestamps.peek(channel);\r\n    distinct = interval > atom;\r\n    if(distinct) {\r\n\t\tprior_beat = beats.peek(channel, 0);\r\n\t\tbeats.poke(prior_beat, channel, 1); //not needed here, but used externally\r\n\t\tbeats.poke(stats.peek(5), channel, 0);\r\n        prior_timestamps.poke(now, channel);\r\n        if(channel < 16) {\t//exclude recitation (0-based)\r\n/*\r\n# the essential calculation made by the script is determining the \"likelihood\" of a played note, essentially whether\r\n# it is a \"hit\" or \"miss\". every interval between the incoming note and both the user's recent playing and the beats\r\nalready in the song is checked to see if at least one more matching interval exists further out into the past or future. If so,\r\nthe played note is determined to be \"patterned\". If this pattern of at least 3 notes includes an already established\r\nsong beat, it is also determined to be \"connected\".in this way, played notes are considered hits if they are \"connected\"\r\nto the existing song through some sort of pattern. Before the song begins, simply being \"patterned\" is enough to begin the song\r\nwith a click track equal to the interval of the pattern.\r\n*/\r\n            likelihood = 0;\r\n            connected = 0;\r\n            patterned = 0;\r\n            needle = play_head.peek(0); //needle is at most recent song beat (in the past)\r\n            //now = timestamp - starting_frame.peek(0) + stats.peek(6);   //add click because the song starts on beat one\r\n            song_start = starting_frame.peek(0);\r\n            out7 = song_start;\r\n            for(j = timestamps; j >= 0; j -= 1) {   //reverberate from the past to incoming timestamp through recent playing\r\n                past_timestamp = playing.peek(j);       //starting at the biggest intervals and working down for the sake of inserting\r\n                interval = now - past_timestamp;        //current timestamp as easily as possible (at index 0). for() starts at last\r\n                if(interval <= wake + atom) {           //timestamp for sake of moving all timestamps and because a pattern might still be found\r\n                    target = past_timestamp - interval; //in greater song from that interval. EDIT: 1 PAST last timestamp because with 0 timestamps\r\n                    local_pattern = 0;                      //1 still needs to be inserted. Interval should safely be impossibly large in this case\r\n                    l = 0;                       //external declaration allows duplicate while()s to iterate without repetition\r\n                    if(lock) {\r\n                        check = past_song.peek(l);                           //1st checks song back into time\r\n                        //if(check) {  //assumes there might be a point briefly when the song locks but has no recitation\r\n                            while(check >= target - tolerance) {\r\n                                if(abs(check - target) <= tolerance) {\t//success\r\n                                    patterned = interval;\r\n\t\t\t\t\t\t\t\t\tlocal_pattern = 1;\r\n                                    connected = 1;\r\n                                    quantized = (check - song_start) / atom;\r\n                                    lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                                    //involvements += 1;\r\n                                    //break;\r\n                                }\r\n                                l += 1;\r\n                                check = past_song.peek(l);\r\n                            }\r\n                        //}\r\n                    }\r\n                    //if(!connected) {    //(save processing where possible) then checks recent playing\r\n                        for(k = j + 1; k < timestamps; k += 1) {    //this loop still works up through remaining timestamps (even though\r\n                            check = playing.peek(k);                //the outer loop is unintuitively working down)\r\n                            if(abs(check - target) <= tolerance) {\t//tentative success\r\n                                patterned = interval;   //patterned documents interval of pattern. This should be the only one conveyed to click assignment\r\n\t\t\t\t\t\t\t\tlocal_pattern = 1;\r\n                                quantized = (check - song_start) / atom;\r\n                                lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                                //involvements += 1;\r\n                                target -= interval;                 //still needs to find a connection in song\r\n                            }\r\n                            if(check < target - tolerance) {\r\n                                break;\r\n                            }\r\n                            if(lock) {\r\n                                check = past_song.peek(l);                           //duplicate while() iterates further if target has been extended\r\n                                //if(check) {  //assumes there might be a point briefly when the song locks but has no recitation\r\n                                    while(check >= target - tolerance) {\r\n                                        if(abs(check - target) <= tolerance) {\t//success\r\n                                            patterned = interval;\r\n\t\t\t\t\t\t\t\t\t\t\tlocal_pattern = 1;\r\n                                            connected = 1;\r\n                                            quantized = (check - song_start) / atom;\r\n                                            lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                                            //involvements += 1;\r\n                                            //break;\r\n                                        }\r\n                                        l += 1;\r\n                                        check = past_song.peek(l);\r\n                                    }\r\n                                //}\r\n                            }\r\n                        }\r\n                    //}\r\n                    if(local_pattern) {\r\n                        quantized = (now - song_start) / atom;\r\n                        lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                        quantized = (past_timestamp - song_start) / atom;\r\n                        lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                        //patterns += 1;\r\n                        //involvements += 2;\t//+2 for beat and future_beat\r\n                    }\r\n                    playing.poke(past_timestamp, j + 1);    //move this timestamp up one spot\r\n                    //timestamps = max(timestamps, j + 2);    //j is the index, timestamps is the quantity\r\n                }\r\n                else if(timestamps) {                  //clean up this timestamp\r\n                    playing.poke(0, j);\r\n                    timestamps -= 1;\r\n                }\r\n                if(!j) {    //when at the beginning, insert current timestamp\r\n                    playing.poke(now, 0);\r\n                    timestamps += 1;\r\n                }\r\n            }\r\n            if(lock && song.peek(0)) {  //assumes there might be a point briefly when the song locks but has no recitation\r\n                song_size = song_beats.peek(0);\r\n                for(j = needle + 1; j < song_size - 1; j += 1) {   //reverberate forward through song\r\n                    future_beat = song.peek(j);\r\n                    interval = future_beat - now;\r\n                    if(interval <= tolerance) {\t//success; played beat coincides with a song beat\r\n                        //patterned = interval;\t//Coincidence not technically a pattern\r\n                        connected = 1;\r\n                        quantized = (now - song_start) / atom;\r\n                        lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                        quantized = (future_beat - song_start) / atom;\r\n                        lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                        //involvements += 2;\r\n                        //break;\r\n                    }\r\n                    else if(interval <= wake + atom) {\r\n                        target = future_beat + interval;\r\n                        local_pattern = 0;\r\n                        for(k = j + 1; k < song_size; k += 1) { //check remaining beats\r\n                            check = song.peek(k);\r\n                            if(abs(check - target) <= tolerance) {\t//success\r\n                                patterned = interval;\r\n\t\t\t\t\t\t\t\tlocal_pattern = 1;\r\n                                connected = 1;\r\n                                quantized = (check - song_start) / atom;\r\n                                lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                                //involvements += 1;\r\n                                //target += interval;   //no need to keep the chain going until more in-depth stats are desired\r\n                            }\r\n                            if(check > target + tolerance) {    //overshot\r\n                                break;\r\n                            }\r\n                        }\r\n                        if(local_pattern) {\r\n                            quantized = (now - song_start) / atom;\r\n                            lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                            quantized = (future_beat - song_start) / atom;\r\n                            lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                            //patterns += 1;\r\n                            //involvements += 2;\t//+2 for beat and future_beat\r\n                            //break;                  //for now, only point is to determine connected: all loops can end after success\r\n                        }\t\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                j = 0;\r\n                past_beat = past_song.peek(j);\r\n                while(past_beat) {   //reverberate backward through song\r\n                    interval = now - past_beat;\r\n                    if(abs(interval) <= tolerance) {\t//success; played beat coincides with a song beat\r\n                        //patterned = interval;           //abs() because it's possible it past_beat might actually be in the future \r\n                        connected = 1;                  //(Documented at cue start rather than envelope peak)\r\n                        quantized = (now - song_start) / atom;\r\n                        lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                        quantized = (past_beat - song_start) / atom;\r\n                        lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                        //involvements += 2;\r\n                        //break;\r\n                    }\r\n                    else if(interval <= wake + atom) {\r\n                        target = past_beat - interval;\r\n                        local_pattern = 0;\r\n                        k = j + 1;\r\n                        check = past_song.peek(k);\r\n                        while(check) {    //check remaining beats\r\n                            if(abs(check - target) <= tolerance) {\t//success\r\n                                patterned = interval;\r\n\t\t\t\t\t\t\t\tlocal_pattern = 1;\r\n                                connected = 1;\r\n                                quantized = (check - song_start) / atom;\r\n                                lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                                //involvements += 1;\r\n                                //target += interval;   //no need to keep the chain going until more in-depth stats are desired\r\n                            }\r\n                            if(check < target - tolerance) {\r\n                                break;\r\n                            }\r\n                            k += 1;\r\n                            check = past_song.peek(k);\r\n                        }\r\n                        //if(!connected) {    //save processing where possible\r\n                            for(k = 0; k < timestamps; k += 1) {\r\n                                check = playing.peek(k);\r\n                                if(abs(check - target) <= tolerance) {\t//success\r\n                                    patterned = interval;\r\n\t\t\t\t\t\t\t\t\tlocal_pattern = 1;\r\n                                    connected = 1;          //results in a connection because past_beat is part of song\r\n                                    quantized = (check - song_start) / atom;\r\n                                    lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                                    //involvements += 1;\r\n                                    //target += interval;   //no need to keep the chain going until more in-depth stats are desired\r\n                                }\r\n                                if(check < target - tolerance) {    //overshot\r\n                                    break;\r\n                                }\r\n                            }\r\n                        //}\r\n                        if(local_pattern) {\r\n                            quantized = (now - song_start) / atom;\r\n                            lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                            quantized = (past_beat - song_start) / atom;\r\n                            lattice.poke(lattice.peek(quantized) + .1, quantized);\r\n                            //patterns += 1;\r\n                            //involvements += 2;\t//+2 for beat and future_beat\r\n                            //break;                  //for now, only point is to determine connected: all loops can end after success\r\n                        }\t\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                    j += 1;\r\n                    past_beat = past_song.peek(j);\r\n                }\r\n            }\r\n\t\t\tif(connected) {\r\n\t\t\t\tlikelihood = 1;\r\n\t\t\t}\r\n            if(!lock && patterned) {    //finding any pattern is the criteria for song starting\r\n                stats.poke(1, 10);\t//lock\r\n\t\t\t\tlock = 1;\r\n                likelihood = 1;\r\n            }\r\n            if(lock) {\t//if locked\r\n            \tout2 = likelihood;\r\n                recording.poke(likelihood, channel);\r\n/*\r\nIf any channel currently has likelihood 1, overall recording is 1\r\n*/\r\n                for(i = 0; i < dim(recording); i += 1) {\r\n                    channel_recording = recording.peek(i);\r\n                    stats.poke(channel_recording, 9);\t//recording\r\n                    out1 = channel_recording;\r\n                    if(channel_recording) {\r\n                        break;\r\n                    }\r\n                }\r\n                click = stats.peek(6);\r\n                if(!click) {\r\n                    if(backing) {\r\n                        stats.poke(backing, 6);\r\n                        out5 = backing;\r\n                    }\r\n                    else {\r\n                        stats.poke(patterned, 6);\r\n                        out5 = patterned;\r\n                    }\r\n                }\r\n                out4 = 1;\t//tempo disabled currently\r\n            }\r\n\t\t\tout3 = lock;\r\n        }\r\n\t}\r\n}\r\n\r\nout6 = ((stats.peek(1) + 1) * stats.peek(6)) / atom;  //Length of song for lattice waveform~\r\n//out6 = sampstoms(((stats.peek(1) + 1) * stats.peek(6)) / atom);  //Length of song for lattice waveform~",
					"fontface" : 0,
					"fontname" : "Lucida Console",
					"fontsize" : 10.0,
					"id" : "obj-3",
					"maxclass" : "codebox",
					"numinlets" : 4,
					"numoutlets" : 7,
					"outlettype" : [ "", "", "", "", "", "", "" ],
					"patching_rect" : [ 0.0, 20.0, 670.0, 520.0 ]
				}

			}
 ],
		"lines" : [ 			{
				"patchline" : 				{
					"destination" : [ "obj-3", 0 ],
					"source" : [ "obj-1", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-3", 1 ],
					"source" : [ "obj-2", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-10", 0 ],
					"source" : [ "obj-3", 4 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-11", 0 ],
					"source" : [ "obj-3", 5 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-12", 0 ],
					"source" : [ "obj-3", 6 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-4", 0 ],
					"source" : [ "obj-3", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-7", 0 ],
					"source" : [ "obj-3", 1 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-8", 0 ],
					"source" : [ "obj-3", 2 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-9", 0 ],
					"source" : [ "obj-3", 3 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-3", 2 ],
					"source" : [ "obj-5", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-3", 3 ],
					"source" : [ "obj-6", 0 ]
				}

			}
 ],
		"bgfillcolor_type" : "gradient",
		"bgfillcolor_color1" : [ 0.376471, 0.384314, 0.4, 1.0 ],
		"bgfillcolor_color2" : [ 0.290196, 0.309804, 0.301961, 1.0 ],
		"bgfillcolor_color" : [ 0.290196, 0.309804, 0.301961, 1.0 ]
	}

}
